package com.r3.corda.lib.ci

import net.corda.core.CordaInternal
import net.corda.core.crypto.DigitalSignature
import net.corda.core.crypto.SignedData
import net.corda.core.crypto.sha256
import net.corda.core.internal.VisibleForTesting
import net.corda.core.node.ServiceHub
import net.corda.core.serialization.CordaSerializable
import net.corda.core.serialization.SerializedBytes
import net.corda.core.serialization.serialize
import net.corda.core.utilities.OpaqueBytes
import java.security.PublicKey
import java.security.SignatureException
import java.util.*

/**
 * Unique arbitrary identifier when a key-generating node is creating a [SignedOwnershipClaim].
 */
typealias OwnershipClaim = OpaqueBytes

/**
 * Generates and returns a signed [SignedOwnershipClaim] which contains data on the newly generated [PublicKey] to be associated
 * with the provided external ID.
 *
 * @param serviceHub The [ServiceHub] of the node which requests a new public key
 * @param uuid The external ID to be associated with the new [PublicKey]
 */
@CordaInternal
@VisibleForTesting
fun createSignedOwnershipClaimFromUUID(serviceHub: ServiceHub, nonce: OwnershipClaim, uuid: UUID): SerializedSignedOwnershipClaim<SignedOwnershipClaim> {
    require(nonce.sha256().size == 32)
    val nodeParty = serviceHub.myInfo.legalIdentities.first()
    val newKey = serviceHub.keyManagementService.freshKey(uuid)
    val signedOwnershipClaim = SignedOwnershipClaim(nonce, newKey)
    val hostNodeSig = serviceHub.keyManagementService.sign(signedOwnershipClaim.serialize().hash.bytes, nodeParty.owningKey)
    val newKeySig = serviceHub.keyManagementService.sign(signedOwnershipClaim.serialize().hash.bytes, newKey)
    return SerializedSignedOwnershipClaim(signedOwnershipClaim.serialize(), hostNodeSig, newKeySig)
}

/**
 * Generates and returns a signed [SignedOwnershipClaim] created against a known [PublicKey] that is provided to the method.
 *
 * @param serviceHub The [ServiceHub] of the node which requests a new public key
 * @param knownKey The [PublicKey] to be mapped to the node party
 */
@CordaInternal
@VisibleForTesting
fun createSignedOwnershipClaimFromKnownKey(serviceHub: ServiceHub, nonce: OwnershipClaim, knownKey: PublicKey): SerializedSignedOwnershipClaim<SignedOwnershipClaim> {
    require(nonce.sha256().size == 32)
    val nodeParty = serviceHub.myInfo.legalIdentities.first()
    val signedOwnershipClaim = SignedOwnershipClaim(nonce, knownKey)
    val hostNodeSig = serviceHub.keyManagementService.sign(signedOwnershipClaim.serialize().hash.bytes, nodeParty.owningKey)
    val newKeySig = serviceHub.keyManagementService.sign(signedOwnershipClaim.serialize().hash.bytes, knownKey)
    return SerializedSignedOwnershipClaim(signedOwnershipClaim.serialize(), hostNodeSig, newKeySig)
}

/**
 * Verifies the [DigitalSignature.WithKey] on the [SignedOwnershipClaim] matches the signature of the node that generated it as
 * well as the the signature generated by the new [PublicKey] that is present in the [SignedOwnershipClaim].
 */
@CordaInternal
@VisibleForTesting
fun validateHostNodeAndPublicKeySignatures(signedOwnershipClaim: SerializedSignedOwnershipClaim<SignedOwnershipClaim>) {
    try {
        signedOwnershipClaim.hostNodeSig.verify(signedOwnershipClaim.raw.hash.bytes)
        signedOwnershipClaim.publicKeySig.verify(signedOwnershipClaim.raw.hash.bytes)
    } catch (ex: SignatureException) {
        throw SignatureException("The signature provided does not match that of identity that created signed ownership", ex)
    }
}

/**
 * Object that holds parameters that drive the behaviour of flows that consume it. The [UUID] can be provided to generate a
 * new [PublicKey] to be associated with the external ID. A known [PublicKey] can be provided to instruct the node to register
 * a mapping between that public key and the node party.
 *
 * @param _nonce Arbitrary number that can only be used once in a cryptographic communication
 * @param _uuid The external ID for a new key to be mapped to
 * @param knownKey The [PublicKey] to be mapped to the node party
 */
@CordaSerializable
class CreateKeyForAccount(private val _nonce: OwnershipClaim, private val _uuid: UUID?, val knownKey: PublicKey?) {
    constructor(nonce: OwnershipClaim, knownKey: PublicKey) : this(nonce, null, knownKey)
    constructor(nonce: OwnershipClaim, uuid: UUID) : this(nonce, uuid, null)

    val uuid: UUID?
        get() = _uuid

    val nonce: OpaqueBytes
        get() = _nonce
}

/**
 * To be used in conjunction with [SignedData] when using confidential identities. The [PublicKey] represents the owning key of a
 * confidential identity.
 *
 * @param nonce Arbitrary unique number
 * @param key The [PublicKey] to be actioned
 */
@CordaSerializable
data class SignedOwnershipClaim(val nonce: OwnershipClaim, val key: PublicKey)

/**
 * A serialized version of [SignedOwnershipClaim]]and the signature of the node that generated it, as well as the [PublicKey] contained
 * within the [SignedOwnershipClaim]. Enforces signature validity in order to deserialize the data
 * contained within.
 *
 * @param raw the raw serialized data.
 * @param hostNodeSig the (unverified) signature for node that generated the [SignedOwnershipClaim].
 * @param publicKeySig the (unverified) signature for the new [PublicKey].
 */
@CordaSerializable
data class SerializedSignedOwnershipClaim<T : Any>(val raw: SerializedBytes<T>, val hostNodeSig: DigitalSignature.WithKey, val publicKeySig: DigitalSignature.WithKey)